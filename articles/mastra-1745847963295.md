---
title: "Mastraのサブワークフロー活用術：複雑な処理をモジュール化する"
emoji: "🧩"
type: "article"
topics: ["mastra", "workflow", "typescript", "ai", "modularization"]
published: false
---

---
title: "Mastraのサブワークフロー活用術：複雑な処理をモジュール化する"
emoji: "🧩"
type: "tech"
topics: ["mastra", "workflow", "typescript", "ai", "modularization"]
published: false
---

# Mastraのサブワークフロー活用術：複雑な処理をモジュール化する

Mastraフレームワークを使っていると、ワークフローが次第に複雑化していくことがあります。ステップ数が増え、ロジックが入り組んでくると、全体の見通しが悪くなり、メンテナンス性も低下しがちです。このような課題を解決する強力な機能が「サブワークフロー」です。

この記事では、Mastraのサブワークフローの仕組みと、その活用方法について解説します。

## サブワークフローとは？

サブワークフローとは、**再利用可能なワークフローの単位**のことです。大きなワークフローを複数の小さな、自己完結したワークフロー（＝サブワークフロー）に分割することで、処理をモジュール化できます。

例えば、「注文処理」という大きなワークフローがあった場合、「在庫確認」「決済処理」「顧客への通知」といった部分をそれぞれ独立したサブワークフローとして定義できます。

## サブワークフローのメリット

サブワークフローを活用することで、以下のようなメリットが得られます。

1.  **モジュール性の向上**: 関連する処理を一つの単位にまとめることで、ワークフロー全体の構造が明確になります。
2.  **再利用性の向上**: 共通の処理（例: ユーザー認証、通知送信）をサブワークフロー化しておけば、複数の親ワークフローから呼び出して再利用できます。
3.  **テスト容易性の向上**: 各サブワークフローを個別にテストできるため、デバッグや品質保証が容易になります。
4.  **保守性の向上**: 特定の処理に変更が必要な場合、該当するサブワークフローだけを修正すればよく、影響範囲を限定できます。

## サブワークフローの作成方法

驚くほど簡単です。**サブワークフローは、通常のMastraワークフローと全く同じように作成します。**

特別な構文は必要ありません。`Workflow`クラスと`Step`クラスを使って、再利用したい一連の処理を定義するだけです。

```typescript
import { Workflow, Step } from '@mastra/core/workflows';
import { z } from 'zod';
import { mastra } from '../index'; // Mastraインスタンスをインポート

// サブワークフローとして利用する「決済処理」ワークフロー
export const paymentProcessingWorkflow = new Workflow({
  name: 'payment-processing-sub-workflow',
  // サブワークフローが受け取るデータ（トリガー）のスキーマ
  triggerSchema: z.object({
    orderId: z.string(),
    amount: z.number(),
    userId: z.string(),
  }),
  mastra,
});

// 決済APIを呼び出すステップ（仮）
const callPaymentApiStep = new Step({
  id: 'call-payment-api',
  inputSchema: z.object({
    orderId: z.string(),
    amount: z.number(),
  }),
  outputSchema: z.object({
    paymentSuccess: z.boolean(),
    transactionId: z.string().optional(),
  }),
  execute: async ({ context }) => {
    console.log(`Processing payment for order ${context.input.orderId}, amount ${context.input.amount}...`);
    // ここで実際の決済API呼び出しを行う
    const success = Math.random() > 0.2; // 80%で成功する仮実装
    return {
      paymentSuccess: success,
      transactionId: success ? `txn_${Date.now()}` : undefined,
    };
  },
});

paymentProcessingWorkflow
  .step(callPaymentApiStep)
  .commit();
```

重要なのは、このワークフローが外部から呼び出されることを想定し、`triggerSchema`で必要な入力を定義しておくことです。

## 親ワークフローからのサブワークフロー呼び出し

親ワークフローからサブワークフローを呼び出すには、`Step`の`execute`内で`mastra.run()`メソッドを使用します。

```typescript
import { Workflow, Step } from '@mastra/core/workflows';
import { z } from 'zod';
import { mastra } from '../index';
import { paymentProcessingWorkflow } from './paymentProcessingWorkflow'; // 作成したサブワークフローをインポート

// 親となる「注文処理」ワークフロー
export const orderProcessingWorkflow = new Workflow({
  name: 'order-processing-main-workflow',
  triggerSchema: z.object({
    orderId: z.string(),
    items: z.array(z.string()),
    totalAmount: z.number(),
    userId: z.string(),
  }),
  mastra,
});

// 在庫確認ステップ（仮）
const checkInventoryStep = new Step({
  id: 'check-inventory',
  inputSchema: z.object({ items: z.array(z.string()) }),
  outputSchema: z.object({ inventoryAvailable: z.boolean() }),
  execute: async ({ context }) => {
    console.log('Checking inventory...');
    return { inventoryAvailable: true }; // 仮実装
  },
});

// サブワークフローを呼び出すステップ
const runPaymentSubWorkflowStep = new Step({
  id: 'run-payment-sub-workflow',
  // サブワークフローに必要なデータを入力として受け取る
  inputSchema: z.object({
    orderId: z.string(),
    amount: z.number(),
    userId: z.string(),
  }),
  // サブワークフローの最終結果（output）を受け取るスキーマ
  outputSchema: z.object({
    paymentSuccess: z.boolean(),
    transactionId: z.string().optional(),
  }),
  execute: async ({ context }) => {
    console.log(`Calling payment sub-workflow for order ${context.input.orderId}`);

    // mastra.run() でサブワークフローを実行
    const subWorkflowRun = await mastra.run({
      workflowName: paymentProcessingWorkflow.name, // 呼び出すサブワークフロー名
      triggerData: { // サブワークフローに渡すデータ
        orderId: context.input.orderId,
        amount: context.input.amount,
        userId: context.input.userId,
      },
    });

    // サブワークフローの実行結果を取得
    const finalResult = await subWorkflowRun.output();

    console.log('Payment sub-workflow finished with result:', finalResult);
    return finalResult; // 結果を親ワークフローの次のステップに渡す
  },
});

// 顧客通知ステップ（仮）
const notifyCustomerStep = new Step({
  id: 'notify-customer',
  inputSchema: z.object({
    userId: z.string(),
    paymentSuccess: z.boolean(),
  }),
  execute: async ({ context }) => {
    console.log(`Notifying customer ${context.input.userId} about payment status: ${context.input.paymentSuccess}`);
    // 通知処理
  },
});

// ワークフローの定義
orderProcessingWorkflow
  .step(checkInventoryStep)
  // 在庫がある場合のみ決済処理へ
  .when((ctx) => ctx.result.inventoryAvailable)
  .step(runPaymentSubWorkflowStep, {
    // 前のステップの出力とトリガーデータをマッピング
    mapInput: (ctx) => ({
      orderId: ctx.triggerData.orderId,
      amount: ctx.triggerData.totalAmount,
      userId: ctx.triggerData.userId,
    }),
  })
  .step(notifyCustomerStep, {
    // 前のステップ（サブワークフローの結果）とトリガーデータをマッピング
    mapInput: (ctx) => ({
      userId: ctx.triggerData.userId,
      paymentSuccess: ctx.result.paymentSuccess, // サブワークフローの結果を参照
    }),
  })
  .commit();
```

ポイントは以下の通りです：

-   `import`で呼び出したいサブワークフロー（実体は`Workflow`インスタンス）を読み込む。
-   `Step`の`execute`内で`mastra.run()`を呼び出す。
    -   `workflowName`にサブワークフローの`name`を指定。
    -   `triggerData`にサブワークフローが必要とするデータを渡す。
-   `await subWorkflowRun.output()`でサブワークフローの最終的な出力結果を取得できる。
-   `mapInput`を使って、親ワークフローのデータや前のステップの結果を、サブワークフロー呼び出しステップの入力に適切にマッピングする。

## エラーハンドリング

サブワークフロー内でエラーが発生した場合、`mastra.run()`はエラーを含む実行結果を返します。親ワークフロー側では、`subWorkflowRun.status`などを確認して、エラーに応じた処理（リトライ、フォールバックなど）を実装できます。

```typescript
  execute: async ({ context }) => {
    const subWorkflowRun = await mastra.run({ /* ... */ });

    if (subWorkflowRun.status === 'failed') {
      console.error('Sub-workflow failed:', subWorkflowRun.error);
      // エラー処理（例: 例外をスロー、フォールバック処理）
      throw new Error('Payment processing failed');
    }

    const finalResult = await subWorkflowRun.output();
    return finalResult;
  },
```

## まとめ

Mastraのサブワークフローは、複雑なプロセスを管理しやすくするための強力な機能です。特別な構文は不要で、通常のワークフロー定義と`mastra.run()`による呼び出しを組み合わせるだけで実現できます。

ワークフローが複雑になってきたと感じたら、共通処理や論理的なまとまりをサブワークフローとして切り出すことを検討してみてください。コードの再利用性、テスト容易性、保守性が大幅に向上するはずです。
